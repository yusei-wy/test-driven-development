* テスト駆動開発
** TODO リスト [62%]
# 次にやることは太字にする
# 作業が終わったら打ち消し線を引いたりチェックする
- [ ] $5 + 10 CHF = $10（レートが 2:1 の場合）
- [X] $5 * 2 = $10
- [X] amount を private にする
- [X] Dollar の副作用を解決する（新しいオブジェクトを返す）
- [ ] Money の丸め処理どうする
- [X] equals()
- [ ] hashCode()
- [ ] null との等価性比較
- [ ] 他のオブジェクトとの等価性比較
- [X] 5 CHF * 2 = 10 CHF
- [X] Dollar と Franc の重複
- [X] equals の一般化
- [X] times の一般化
- [X] Dollar と Franc を比較する
- [X] 通貨の概念
- [ ] TestFrancMultiplication を削除する？

** New TODO リスト [50%]
- [ ] $5 + 10 CHF = $10（レートが 2:1 の場合）
- [ ] *$5 + $5 = $10*
- [ ] $5 + $5 が Money を返す
- [X] Bank.reduce(Money)
- [ ] Money を変換して換算を行う
- [ ] Reduce(Bank, string)

*** [memo]
- 一気に全ての機能をテストしない
- 一つずつ Red -> Green -> リファクタリングのサイクルを回す
- テストが通るコード＝完成品ではない
- テストで期待する値をハードコードなどで返す様な状態を意味する
- これによって本当に必要なインターフェースが見えてくる
- *リファクタリング* のフェーズで修正を行う

** 第1章 仮実装 - Multi-Currency Money
銘柄、株数、価格、合計の項目を持つレポートを多国通貨対応させるために通貨情報が必要
加えて通過レートも規定しないといけない
どうすればレポートを多国通貨に対応させられる？
言い換えるとどんなテストを書けば、そのテストが通った時にレポートを正しく出すコードが完成したと自身を持っていえる？

次のことから考えてみる
- 通貨の異なる2つの金額を足し、通貨間の為替レートに基づいて換された金額を得る
- 金額（通貨単位あたりの額）に数値（通貨単位数）を掛け金額を得る

** 第8章 実装を隠す - Makin' Objects
ここでは Dollar と Franc の重複を問題として、親クラスである Money に Dollar の Factory Method `dollar()` を定義している。
私は Go でコードを書いているのでこの考え方は適さない。（シンプルさ、明快さに重きをおく言語だから）

じゃあどうする？
- 共通処理は埋め込みを使う
- 型ごとに振る舞いを変更したいなら interface を使う

** 第10章 テストに聞いてみる
ここでは `times()` メソッドを親クラス `Money` に移動させて一般化している。
`times()` はそれぞれのサブクラスの型を返すがこれが `equal()` で機能しなくなっていた。
`currency` 通貨が異なる場合を考慮していなかったからだ。
`currency` を親のフィールドとしていて、`equals()` では `currency` も比較する様にしている。

しかし、そもそも別の通貨で、別の型としておいた方がシンプル。
異なる型を比較したいならパッケージ関数を用意して、引数を interface とすることで振る舞いは変更できそう。
または、変換メソッドで片方の型に合わせるなど。

** 第12章 設計とメタファー
*** 制約
- 複数の通貨を扱っていることをほとんど意識させないコードにしたい
- 基準通貨への変換では為替レートの変更をうま靴扱えない
*** Importer オブジェクトで解決する
Money のように振る舞うが、2つの Money の合計を表現するオブジェクト
*** Expression メタファー
ex. `($2 + 3 CHF) * 5`
式のメタファーにおいて Money は最小構成要素で、さまざまな操作の結果は Expression オブジェクトの形になる（その一つが Sum）

- Expression は通貨計算の中核を成すもの
  中核を成すオブジェクトがそれ以外の事柄をできるだけ知らない様な設計を続けるメリット
  1. 柔軟性が高い
  2. テストがしやすく再利用性も高い
  3. 理解が簡単

- Expression がかかる操作はこれから増えていくと想像できる
  すべての操作を Expression に加えていくとファットオブジェクトになる
*** Bank オブジェクト
通貨を換算するのは式ではなく銀行の責務だと考えられる
↑の Expression の方向性で問題なく Bank オブジェクトの関与が不要だとわかったら、換算の責務を Expression に移動する
